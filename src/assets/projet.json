[
    { 
        "name": "CV",
        "title": "Curriculum Vitae",
        "description": {
            "lien": "Pour le premier projet effectué dans le cadre de ma formation, je vous présente mon CV.", 
            "description": "J'ai réalisé tout le travail de maquettage sur l'outil FIGMA."
        },
        "lien": [
            { "text": "CV en ligne", "lien": "http://cv.bauwens-delphine.com/"},
            { "text": "Zoning Figma", "lien": "https://www.figma.com/file/pfNRJm4LhVKuMvLP2Znb7j/CV-Wireframe?type=design&node-id=0%3A1&mode=design&t=rgIWx7RMUJEC61g0-1"},
            { "text": "Wireframe Figma", "lien": "https://www.figma.com/file/pfNRJm4LhVKuMvLP2Znb7j/CV-Wireframe?type=design&node-id=127-101&mode=design&t=9vDG4hMpT14Rtpqb-0"},
            { "text": "Feuille de Style Figma", "lien": "https://www.figma.com/file/pfNRJm4LhVKuMvLP2Znb7j/CV-Wireframe?type=design&node-id=125-101&mode=design&t=9vDG4hMpT14Rtpqb-0"}
        ],
        "contenu": [
            {"alt": "Le zoning", "inter":"", "lien": "./src/assets/img/wireframe.png"}, 
            {"alt": "Le wireframe", "inter":"", "lien": "./src/assets/img/maquette.png"}, 
            {"alt": "La feuille de style", "inter": "Concernant la partie développement, j'ai utilisé l'éditeur de code Visual Studio Code.\\nJ'ai utilisé le framework Bootstrap en important les différentes lignes de code nécessaire comme indiqué dans la documentation.", "lien": "./src/assets/img/feuille_de_style.png"}, 
            {"alt": "Extrait du fichier html", "inter":"L'import de Boostrap m'a permis de développer mon formulaire de contact de manière responsive en quelques minutes.", "lien": "./src/assets/img/index.html.png"}, 
            {"alt": "La console de développement", "inter":"Pour finir, l'utilisation de la console de développement sur navigateur m'a permis d'adapter le contenu aux différentes plateformes", "lien": "./src/assets/img/console_developpement.png"}, 
            {"alt": "Vue ordinateur et vue mobile", "inter":"", "lien": "./src/assets/img/maquette_cv.png"} 
        ]
    },
    {
        "name": "WordPress",
        "title": "WordPress",
        "description": {"lien": "Le deuxième projet, effectué dans le cadre de ma formation, sera présenté l'entreprise de Monsieur Riolacci, artisan fromager.", "description": "Afin de procéder au développement, j'ai créer un serveur grâce à AWS EC2. J'ai procédé à l'installation de Nginx, ainsi que d'un certificat SSL, et j'ai configurer le chemin d'accès.\\nAvant de mettre en place la boutique, j'ai procédé à divers ajustements nécéssaires afin de garantir la sécurité du site internet."},
        "lien": [{"text": "Riolacci", "lien": "http://wordpress.bauwens-delphine.com/"}],
        "contenu": [
            {"alt": "Serveur AWS EC2", "inter":"", "lien": "./src/assets/img/aws_ec2.png"},
            {"alt": "Sites-available", "inter":"", "lien": "./src/assets/img/sites-availables.png"}, 
            {"alt": "Configuration oceanwp-child", "inter":"J'ai créé un dossier oceanwp-child, dans lequel j'ai créé 2 ficihers:\\n<strong>→</strong>\\tfunctions.php qui contient la fonction qui charge le style du thème parent et du thème enfant\\n<strong>→</strong>\\tstyle.css qui contiendra les modifications du style appliquées au thème enfant\\nUne fois le thème enfant créé, il apparait dans le tableau de bord WordPress, je l'ai donc activé comme thème du site.", "lien": "./src/assets/img/oceanwp-child.png"}, 
            {"alt": "Extensions Wordpress", "inter":"Ensuite, j'ai procédé à l'ensemble des mises à jour, après avoir effectué une sauvegarde du site à l'aide de l'extension 'UpdraftPlus'. Pour sécuriser le site, j'ai procédé à l'installation de l'extension SecuPress, et suivi les recommandations indiquées.\\nUne fois le site mis à jour, j'ai pu commencer la mise en place de la boutique e-commerce. Pour cela, j'ai utilisé l'extension WooCommerce qui permet de mettre en place une boutique e-commerce sur un site WordPress.", "lien": "./src/assets/img/extensions.png"}, 
            {"alt": "Onglet WooCommerce, liste des commandes", "inter":"", "lien": "./src/assets/img/commande.png"}, 
            {"alt": "Onglet Produit, liste des produits", "inter":"Une fois l'extension WooCommerce installée, nous avons accès à 2 nouveaux onglets 'WooCommerce' et 'Produits' dans le tableau de bord WordPress. \\nL'onglet WooCommerce nous donne accès notamment à la liste des commandes effectuées, à la liste des clients et également à un ensemble de paramètres, par exemple:\\n<strong>→</strong>\\tLes types de paiements autorisés sur la boutique\\n<strong>→</strong>\\tLes modalités de livraison (que j'ai décidé de désactiver car il n'y avait pas de livraison possible)\\n<strong>→</strong>\\tLes modalités de livraison (que j'ai décidé de désactiver car il n'y avait pas de livraison possible)\\n<strong>→</strong>\\tLes modes de livraison des clients (s'ils peuvent commander sans compte, par exemple).\\nL'onglet 'Produits' nous permet d'ajouter les produits qui seront mis en vente, de visualiser la liste des produits, d'ajouter des catégories et des étiquettes.", "lien": "./src/assets/img/produits.png"}, 
            {"alt": "Réglage des différents modes de paiements acceptés", "inter":"", "lien": "./src/assets/img/stripe.png"}, 
            {"alt": "Configuration du module Stripe avec mise en place des clés de test", "inter":"Monsieur Riolacci, le client, souhaitait que les commandes soient directement retirées sur place, et que le paiement se fasse en ligne par carte bancaire. J'ai donc mise en place le module de paiement Stripe.", "lien": "./src/assets/img/cle_test.png"}, 
            {"alt": "Boutique contenant des produits", "inter":"", "lien": "./src/assets/img/produit.png"}, 
            {"alt": "Visuel de la page de paiement, mise en place avec une carte bleue", "inter":"Le module de paiement Stripe, intégré à Wordpress, permet de mettre en place facilement le mode de paiement par carte bancaire. Après enregistrement, il est possible de récupérer les clé de test, afin de simuler une vraie commande sur sa boutique", "lien": "./src/assets/img/paiement.png"}, 
            {"alt": "Cartes de paiement fictives ", "inter":"", "lien": "./src/assets/img/stripe_doc.png"}
        ]
    },
    {
        "name": "React",
        "title": "Commentaire",
        "description": {"lien":"Pour le troisième projet, je met en forme une interface de gestion des commentaires.", "description": "Au cour de la formation, nous avons étudié le langage Javascript, puis, plus particulièrement la librairie React, librairie Javascript qui permet de créer des interfaces utilisateur.\\nAfin de mettre en pratique nos apprentissages, nous avons dû reproduire une interface de gestion de commentaires.\\nElle devait contenir:\\n<strong>→</strong>\\tun formulaire pour ajouter un commentaire\\n<strong>→</strong>\\tun emplacement où s'affichaient les commentaires ajoutés\\n<strong>→</strong>\\tun bouton qui permettait de passer en mode d'administration, qui lui seul permettait d'effacer les commentaires précédemment ajoutés.\\nPour la mise en forme, nous devions utiliser le framework Bulma.\\nPour le développement, j'ai utilisé l'éditeur de code Visual Studio Code. J'ai installé Bulma grâce à la commande:\\n<kbd>npm install bulma</kbd>\\nEnsuite, il suffit d'importer uniquement ce dont on a besoin dans le fichier index.scss."},
        "lien": [{"text": "Gestion des commentaires", "lien": "http://react.bauwens-delphine.com/"}],
        "contenu": [
            {"alt": "import des composants Bulma nécessaire + personnalisation du thème", "inter":"Concernant le développement React, j'ai créé 4 composants:\\n<strong>→</strong>\\t&lt;CommentList&gt; qui s'occupera de l'affichage des commentaires et de leur bouton de suppression\\n<strong>→</strong>\\t&lt;CommentForm&gt; qui s'occupera de làffichage du formulaire et du traitement des données saisies\\n<strong>→</strong>\\t&lt;AdminMode&gt; qui s'occupera de l'affichage du bouton qui activera et désactivera le mode admin\\n<strong>→</strong>\\t&lt;Article&gt; qui s'occupera de l'affichage du contenu de l'article\\nLe composant &lt;CommentForm&gt; traite les données enregistrées grâce aux fonctions handleChangeName, handleChangeMessage et handleSubmit, qui récupèrent et stockent les données saisies par l'utilisateur.", "lien": "./src/assets/img/style.scss.png"},
            {"alt": "Composant CommentForm", "inter":"Dans le composant &lt;CommentList&gt;, l'affichage des boutons de suppression dépend de l'état de la variable isAdmin en ajustant la classe des boutons de suppression qui passe de 'delete' à 'delete is-invisible' qui sont des classes Bulma.", "lien": "./src/assets/img/commentform.png"},
            {"alt": "Composant CommentList", "inter":"Le composant &lt;AdminMode&gt; adapte l'affichage du bouton en fonction de la variable 'isAdmin' et en adaptant la couleur à l'aide de la variable 'classMessage'.", "lien": "./src/assets/img/commentlist.png"},
            {"alt": "Composant AdminMode", "inter":"Le composant &lt;Article&gt; affiche l'article.", "lien": "./src/assets/img/adminmode.png"},
            {"alt": "Composant Article", "inter":"Une fois ces composants créés, il me suffit de les importer dans mon fichier App.js.\\nC'est dans ce fichier que sera géré l'état 'isAdmin' dont dépandent les composants AdminMode et CommentList, qui ont un affichage conditionnel qui dépend de cette variable booléenne:", "lien": "./src/assets/img/article.png"},
            {"alt": "Composant App.js", "inter":"", "lien": "./src/assets/img/app.js.png"}
        ] 
    },
    {
        "name": "BDD",
        "title": "Quipoquizz",
        "description": { "inter":"", "lien": "Pour la conception d'une base de données, j'ai utilisé la méthode Merise. Je me suis basée sur le quizz QuipoQuizz.", "description": "Pour mettre en application ce que nous avions appis, il nous a été demandé de conceptualiser une base de données d'une application de multi-quizz, semblable à l'application en ligne 'QuipoQuizz'.\\nAu sein de cette application, il existe plusieurs catégories, qui contiennent plusieurs quizz, qui, eux, contiennent des questions.\\nA la fin de chaque quizz, on obtient le score moyen obtenu par l'ensemble des autres joueurs.\\nJ'ai commencé par élaborer le MCD, le modèle conceptuel de données, qui consiste à créer les différentes entités qui composeront le sytème d'information, et à établir des relations entre-elles.\\nAinsi, j'obtiens les entités 'Category', 'Quizz', 'Question' et 'Result', composées de leur propriétés.\\nEnsuite, j'établis les cardinalités:\\n<strong>→</strong>\\tun quizz n'appartient qu'à une seule catégorie, mais une catégorie possède entre 0 et plusieurs quizz.\\n<strong>→</strong>\\tun quizz comporte entre 1 à plusieurs questions, mais une question n'appartient qu'à un seul quizz.\\n<strong>→</strong>\\tun quizz possède entre 0 et plusieurs résultats, et un résultat n'appartient qu'à un seul quizz.\\nUne fois les cardinalités établies, je peux passer à l'élaboration du MLD, le modèle logique de données. Chaque entité devient une table, et leur identifiant devient la clé primaire de la table.\\nPour les relations *,1 -- *,n la clé primaire de la table côté *,n devient une clé étrangère de la table côté *,1 créant ainsi la relation entre les tables.\\nLa table 'Quizz' récupère le champ 'category_id' clé étrangère qui fait référence à la clé primaire de la table 'Category'.\\nLa table 'Result' récupère le champ 'quizz_id' clé étrangère qui fait référence à la clé primaire de la table 'Quizz'.\\nLa table 'Question' récupère le champ 'category_id' clé étrangère qui fait référence à la clé primaire de la table 'Quizz'.\\nMaintenant, je peux élaborer le MPD, le modèle physique de données, qui consiste à préciser le type et les possibles restrictions appliquées pour chaque champ qui compose les tables." },
        "lien": [{"text": "", "lien": ""}],
        "contenu": [
            {"alt": "MCD: Modèle Conceptuel de données", "inter":"", "lien": "./src/assets/img/mcd.png"},
            {"alt": "MLD: Modèle Logique de données", "inter":"", "lien": "./src/assets/img/mld.png"},
            {"alt": "MPD: Modèle Physique de données\\nSchéma de la base de données", "inter":"Une fois le MPD établi, je peux écrire le code SQL qui permettra de générer la base de données.\\nCREATE DATABASE IF NOT EXISTS quipoquizz;\\nUSE QUIPOQUIZZ;\\nCREATE TABLE category (\\n    id INT UNSIGNED PRIMARY KEY NOT NULL AUTO_INCREMENT ,\\n    name VARCHAR(50) NOT NULL,\\n    slug VARCHAR(50) NOT NULL\\n);\\nCREATE TABLE quizz (\\n    id INT UNSIGNED PRIMARY KEY NOT NULL AUTO_INCREMENT,\\n    name VARCHAR(50) NOT NULL,\\n    slug VARCHAR(50) NOT NULL,\\n    category_id INT UNSIGNED\\n);\\nALTER TABLE quizz\\nADD CONSTRAINT FK_category_quizz\\nFOREIGN KEY(category_id)\\nREFERENCES category(id)\\nON DELETE RESTRICT\\nON UPDATE RESTRICT;\\nCREATE TABLE question(\\nid INT UNSIGNED PRIMARY KEY NOT NULL AUTO_INCREMENT,\\ntitle text,\\nanswer BOOL NOT NULL,\\nquizz_id INT UNSIGNED\\n);\\nALTER TABLE question\\nADD CONSTRAINT FK_question_quizz\\nFOREIGN KEY(quizz_id)\\nREFERENCES quizz(id)\\nON DELETE RESTRICT\\nON UPDATE RESTRICT;\\nCREATE TABLE score (\\nscore INT,\\nquizz_id INT UNSIGNED\\n);\\nALTER TABLE score\\nADD CONSTRAINT FK_quizz_result\\nFOREIGN KEY(quizz_id)\\nREFERENCES quizz(id)\\nON DELETE RESTRICT\\nON UPDATE RESTRICT;", "lien": "./src/assets/img/mpd.png"},
            {"alt": "Code SQL qui permet de générer la base de données", "inter":"J'ai créé d'abord les tables, en précisant le type et les restrictions de chaque colonne. Puis je modifie ces tables afin d'ajouter les contraintes de clés étrangères avec 'ON DELETE' et 'ON UPDATE' en 'RESTRICT' afin d'éviter que la référence ne soit supprimée ou modifiée si cela entraine des données incohérentes.", "lien": ""}
        ] 
    },
    {
        "name": "Node",
        "title": "Node.js",
        "description": { "lien": "Développement d'une API REST et de la base de données d'une application QuipoQuizz.", "Description":"BDD: MongoDB ( https://account.mongodb.com/account/login - connexion avec Google ).\\nServer aws : sudo su\\nnohup node /home/ubuntu/node/server.js.\\nJ'ai procédé à l'installation d'Express au sein du projet.\\n<kbd>npm install --save express</kbd>\\nPour développer la base de données, je devais utiliser le système de gestion de base de données 'MongoDB', ainsi que l'ODM ('Object Document Mapping') 'Mongoose', qui permet une modèlisation d'objets MongoDB sous Node.js et gère la validation des données grâce à des schémas.\\n j'ai donc procédé à l'installation de Mongoose\\n<kbd>npm install mongoose</kbd>\\nJe peux ensuite rédiger les schémas:\\n<strong>→</strong>\\tLa collection 'Category' possède les champs 'title' et 'slug', qui sont des chaînes de caractères et qui sont requises. Le champ 'image' est aussi de type string, mais n'est pas requis\\n<strong>→</strong>\\tLa collection 'Quizz' possède les champs 'title' et 'slug', qui sont des chaînes de caractères et qui sont requises. Le champ 'image' est aussi de type string, mais n'est pas requis. Le champ 'category' est une référence à la collection 'Category' et correspond à l'ID de celle-ci. Quant au champs 'Question', c'est un tableau de données."},
        "lien": [{"text": "QuipoQuizz (suite)", "lien": "http://node.bauwens-delphine.com/"}],
        "contenu": [
            {"alt": "Schéma de l'entité Category", "inter":"", "lien": "./src/assets/img/Category.png"},
            {"alt": "Schéma de l'entité Quizz", "inter":"Une fois les collections créées, je peux importer des données dans la base de données, au format JSON.", "lien": "./src/assets/img/Quizz.png"},
            {"alt": "Collection Quizz", "inter":"Voici à quoi ressemble un item d'une collection, par exemple, le quizz 'Animaux du froid'.", "lien": "./src/assets/img/collection_quizz.png"},
            {"alt": "Item de la collection Quizz", "inter":"Il possède donc un titre, un slug, le champ 'image' a été laissé vide, et il possède un tableau de questions. Une question correspond à un objet au format JSON, comprenant la clé 'title' ayant pour valeur une chaine de caractères, et la clé 'answers', ayant pour valeur un tableau d'objets.\\nChaque réponse possède la clé 'correct' qui a pour valeur un booléen, qui permet de connaitre la réponse et de traiter cette donnée en front.\\n une fois la base de données développée, je peux passer au développement de l'API, en commençant par créer les routes qui correspondent aux différentes requêtes à la base de données.", "lien": "./src/assets/img/itemQuizz.png"},
            {"alt": "Controller de la collection Quizz", "inter":"Le dossier Routes définit les routes de l'application, et celles-ci appellent des fonctions asynchrones définies dans le controller. Le controller de la collection Quizz contient 3 requêtes: la première permet d'envoyer un nouvel enregistrement grâce à la méthode GET, la seconde permet de récupérer l'ensemble des quizzs de la collection, et la troisième permet de récupérer les données d'un quizz passé en paramètre grâce à son slug. On accède au paramètre en récupérant le contenu de 'req.params.slug'.", "lien": "./src/assets/img/quizzController.js.png"},
            {"alt": "Controller de la collection Category", "inter":"Le dossier Routes définit les routes de l'application, et celles-ci appellent des fonctions asynchrones définies dans le controller. Le controller de la collection Category contient 3 requêtes: la première permet d'envoyer un nouvel enregistrement grâce à la méthode GET, la seconde permet de récupérer l'ensemble des catégories de la collection, et la troisième permet de récupérer tous les quizz qui appartiennent à la catégorie passée en paramètre.\\nCette seconde requête est composée de 2 sous-requêtes. Dans un premier temps, on effectue une requête sur la collection Category afin de récupérer l'id de la catégorie à laquelle ils appartiennent, correspond à l'id de la catégorie passée initialement en paramètre.\\nUne fois les controllers créés, il ne me reste plus qu'à initialiser le fichier App.js. Il faut importer Express, Mongoose et CORS (qui permet les requêtes multi-origines).\\nJe précise ensuite divers paramètres qui permettent de connecter l'API à la base de données, les controllers utilisés pour chacune des collections, ainsi que leurs URL.\\nAinsi, on sait que toutes les requêtes concernant les catégories commenceront par '{urlDeLaBaseDeDonnées/categories}'.", "lien": "./src/assets/img/categoriesController.js.png"},
            {"alt": "app.js", "inter":"L'API est donc opérationnelle, nous pouvons démarrer notre serveur grâce à la commande:\\n<kbd>node app.js</kbd>\\nL'outil Postman permet d'effectuer des appels à l'API afin de vérifier si les réponses retournées correspondent à ce que nous souhaitons.\\nVoici un extrait d'un appel fait auprès de l'API: on précise la méthode utilisée (ici GET) ainsi que l'url cible (ici 'http://localhost:3000/categories/technologie'). A cette url est censé retourner l'ensemble des quizzs, ce qui est bien le cas.", "lien": "./src/assets/img/app.js.node.png"},
            {"alt": "Extrait de la réponse de l'API grâce à l'outil Postman", "inter":"L'API est donc fonctionnelle, et peut être utilisée par plusieurs applications multi-quizz, telle qu'une application web ou une application mobile", "lien": "./src/assets/img/postman.png"}
        ] 
    }, 
    {
        "name": "Symfony",
        "title": "Symfony",
        "description": {"lien":"Développement d'une API et de la base de données", "description": "J’ai commencé par initialiser un nouveau projet Symfony, avec une arborescence étudiée pour le développement d’une API, à l’aide de la commande :\\n<kbd>composer create-project symfony/squeleton student-api 4.* </kbd>\\nPuis j’ai installé la plateforme du serveur API :\\n<kbd>composer require api</kbd>\\nAprès avoir créé le fichier .env.local qui contient les identifiants de connexion à la base de donnée, on crée celle-ci grâce à la commande :\\n<kbd>php bin/console doctrine:database:create</kbd>\\nPour faciliter le développement, notre formateur nous a conseillé d’installer le bundle ’ maker-bundle ’ qui nous donne accès à une liste de commandes qui nous permettent d’automatiser certains développements sans avoir à écrire tout le code :\\n<kbd>composer require symfony/maler-bundle –dev</kbd>\\nJ’ai pu ensuite commencer à créer les entités.\\nNos étudiants appartiennent à des promotions et sont affectés à des projets, qui sont identifiés à l’aide de tags.\\nNous devons donc créer plusieurs Entités : ’ Student ’, ’ SchoolYear ’, ’ Project ’ et ’ Tag ’. \\nNous créons ces entités Symfony grâce à la ligne de commande : \\n<kbd>php bin/console –api-resource make:entity Student</kbd>\\nLe ’ --api-resource ’ indique que l’entité doit être visible de l’API. La saisie interactive nous permet de générer facilement nos entités, en précisant le nom des champs, leur type et s’il existe des relations avec d’autres Entités. \\nAinsi, pour l’entité ’ Student ’ par exemple, nous générons grâce à cette commande, le fichier Student.php dans le dossier ’ Entity ’ et le fichier ’ StudentRepository.php ’ qui contiendra les requêtes dont nous aurons besoin. \\nDans l’extrait de code ci-dessous, on remarque grâce aux annotations que nous avons différents champs, tels que l’ ’ id ’, ’ firstname ’ ou ’ lastname ’. \\nLe champ ’ schoolyears ’ quant à lui est une référence à l’entité ’ SchoolYear ’ avec laquelle elle partage une relation ’ Many to Many ’. Cela signifie qu’une promotion peut contenir plusieurs élèves, et qu’un élève peut appartenir à plusieurs promotions."},
        "lien": [{"text": "Symfony", "lien": "http://node.bauwens-delphine.com/"}],
        "contenu": [
            {"alt": "Extrait du fichier Student.php", "inter": "Une fois les entités créées, il faut générer le fichier de migrations et l’appliquer à la base de données. J’installe donc le bundle ’doctrine-migrations-bundle’  :\\n<kbd>composer require doctrine/doctrine-migrations-bundle</kbd>\\nQui me permet d’utiliser la commande suivante, afin de générer le fichier de migrations :\\n<kbd>php bin/console make:migration</kbd>\\nLe fichier de migrations indique comment upgrade la base de données, et comment la downgrade si nécessaire. Le nom du fichier est important, car il permet de savoir quel est le dernier fichier de migration qui a été appliqué à la base de données.", "lien":"./src/assets/img/student.php.png" },
            {"alt": "Extrait du fichier de migration", "inter": "On peut maintenant appliquer le fichier de migration à la base de données, ainsi que ceux qui ont été générés mais pas encore appliqués : \\n <kbd>php bin/console doctrine:migrations:migrate</kbd>\\nOn obtient donc notre base de données :", "lien": "./src/assets/img/migration.png" },
            {"alt": "Base de données", "inter": "Il est possible de n’autoriser qu’un certain type de méthode lors des requêtes sur nos entités. Nous avions comme consigne de n'autoriser que les méthodes « GET » pour l’entité ' Tag '. Pour cela, dans l’entité ' Tag ', il est possible d’ajouter des paramètres dans l’annotation ' ApiResource( ) '. ", "lien": "./src/assets/img/mysql.png" },
            {"alt": "Extrait du fichier Tag.php", "inter": "Je vais également simuler des données grâce à l'outil data-fixtures\\n<kbd>composer require --dev orm-fixtures</kbd>\\n<kbd>composer require --dev doctrine/doctrine-fixtures-bundle</kbd>\\n<kbd>php bin/console doctrine:fixtures:load</kbd>", "lien": "./src/assets/img/tag.png" },
            {"alt": "Data Fixture", "inter": "On constate bien que l’entité « Tag » n’est accessible qu’avec la méthode ' GET '. A l’aide de « Postman », je vérifie que l’API retourne bien les données attendues. Voici la table ' student ' dans la base de données :", "lien": "./src/assets/img/Fixture.png" },
            {"alt": "Interface d'API platform", "inter": "", "lien": "./src/assets/img/API.png" },
            {"alt": "Table Student", "inter": "Voici la réponse de l'API lorsque l'interroge avec POSTMAN", "lien": "./src/assets/img/mysql-data.png" },
            {"alt": "Réponse Postman", "inter": "L’ API est donc fonctionnelle, et peut-être utilisée par plusieurs applications, telle qu’une application web ou une application mobile.", "lien": "./src/assets/img/Postman-symfony.png" }
        ]
    }
]